#!/usr/bin/env python

# Copyright (C) 2016 University of Southern California and
#                        Guido Polles
# 
# Authors: Guido Polles
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''
The **random** module provides functions for the generation
of the initial coordinates
'''

from __future__ import print_function, division
import numpy
import numpy.random
import logging
from functools import partial
import time
from math import acos, sin, cos, pi

from .myio import write_hms
from .util import monitor_progress, pretty_tdelta
from .network_coord_io import CoordServer, CoordClient


__author__  = "Guido Polles"
__license__ = "GPL"
__version__ = "0.0.1"
__email__   = "polles@usc.edu"


def uniform_sphere(R):
    '''
    Generates uniformly distributed points in a sphere
    
    Arguments:
        R (float): radius of the sphere

    Returns:
        numpy.array:
            triplet of coordinates x, y, z 
    '''
    phi = numpy.random.uniform(0, 2 * pi)
    costheta = numpy.random.uniform(-1, 1)
    u = numpy.random.uniform(0, 1)

    theta = acos( costheta )
    r = R * ( u**(1./3.) )

    x = r * sin( theta) * cos( phi )
    y = r * sin( theta) * sin( phi )
    z = r * cos( theta )

    return numpy.array([x,y,z])


def generate_territories(index, R=5000.0):
    '''
    Creates a single random structure with chromosome territories.

    Each "territory" is a sphere with radius 0.75 times the average
    expected radius of a chromosome.

    Arguments:
        chrom : alabtools.utils.Index 
            the bead index for the system.
        R : float 
            radius of the cell
    
    Returns:
        numpy.array : structure coordinates
    '''
    
    # chromosome ends are detected when
    # the name is changed
    n_tot = len(index)
    n_chrom = len(index.chrom_sizes)
    
    crds = numpy.empty((n_tot, 3))
    # the radius of the chromosome is set as 75% of its
    # "volumetric sphere" one. This is totally arbitrary. 
    # Note: using float division of py3
    chr_radii = [0.75 * R * (float(nb)/n_tot)**(1./3) for nb in index.chrom_sizes]
    crad = numpy.average(chr_radii)
    k = 0
    for i in range(n_chrom):    
        center = uniform_sphere(R - crad)
        for j in range(index.chrom_sizes[i]):
            crds[k] = uniform_sphere(crad) + center
            k += 1

    return crds
    

def _write_random_hms(radii, chrom, prefix, i, R=5000.0):
    fname = '%s_%d.hms' % (prefix, i)
    crd = generate_territories(chrom, R=R)
    write_hms(fname, crd, radii, chrom)


def _write_random_to_db(dbname, chrom, prefix, i, R=5000.0):
    from lammps_hic.dbio import DBStructFile
    crd = generate_territories(chrom, R=R)
    f = DBStructFile(dbname, 'r')
    f.write_structure(prefix, i, crd)


def _write_random_to_memmap(fname, chrom, i, R=5000.0):
    n_beads = len(chrom)
    crd = generate_territories(chrom, R=R)
    # assumes 4 bytes floating point
    offset = n_beads*3*4*i
    f = numpy.memmap(fname, mode='r+', dtype='float32', shape=(n_beads, 3), 
                     offset=offset)
    f[:] = crd[:]
    f.flush()


def _write_random_to_server(fname, index, i, R=5000.0):
    from network_coord_io import CoordClient
    crd = generate_territories(index, R=R)
    with CoordClient(fname) as client:
        client.set_struct(i, crd)


from .myio import PopulationCrdFile
from .network_coord_io import CoordServer, CoordClient
def create_random_population_with_territories(path, index, n_struct, ipp_client=None):
    '''
    Creates a population of N = *n_struct* structures, each on a single hms file. 
    Each file path is determined as *<prefix>_<n>.hms* 
    where *n* goes from 0 to N-1.

    Every structure is generated by selecting the chromosome
    centroids, and positioning chromosome beads in a spherical volume 
    around the centroid.
    
    Arguments:        
        radii (iterable): A list containing the radius of each bead
        chrom (iterable): list of strings, one for each bead in the system,
            for example ['chr1', 'chr1', ..., 'chrY']
        n_struct (int): Number of structures in the population
        prefix (str): Prefix of filenames: if prefix='tmp/territories'
            the files tmp/territories_0.hms, tmp/territories_1.hms, 
            etc. will be generated
        ipp_client (ipyparallel.Client): If None, will just produce the 
            population in a serial run.
            If set to a ipyparallel Client instance, will 
            distribute the job to the workers. Requires 
            cloudpickle. 
        dbfile (str): If None, the function will write hms files.
            Else, will use the specified sqlite3 database file to 
            write the coordinates
        memmap (str): If not None, coordinates will be written
            to a numpy memmap instead of a hms or sqlite db.

    Returns:
        N files: *prefix_\*.hms*, with * going from 0 to N-1

    :Exceptions:
        No exceptions raised directly.
    '''
    logger = logging.getLogger(__name__)
    Gb = 8
    membytes = Gb*1024*1024*1024
    n_bead = len(index)


    if ipp_client is None:
        # serial run
        start = time.time()
        logger.info('create_random_population_with_territories():'
                    ' serial run started (%d structures)', n_struct)
            
        with PopulationCrdFile(path, mode='w', shape=(n_struct, n_bead, 3), 
                               max_memory=membytes) as p:
            for i in range(n_struct):
                crd = generate_territories(index)
                p.set_struct(i, crd)

        end = time.time()
        logger.info('create_random_population_with_territories():'
                    ' serial run done. (timing: %s)', 
                    pretty_tdelta(end-start))

    else:
        # parallel run
        with CoordServer(path, mode='w', shape=(n_struct, n_bead, 3), 
                     max_memory=membytes) as cs:
        
            # cloudpickle is needed to send the partial
            genfunc = partial(_write_random_to_server, path, index)
            ipp_client[:].use_cloudpickle() 
            logger.info('create_random_population_with_territories():'
                        ' parallel run started on %d workers',
                        len(ipp_client))

            ar = ipp_client[:].map_async(genfunc, range(n_struct))

            monitor_progress('create_random_population_with_territories()', ar)

            logger.info('create_random_population_with_territories():'
                        ' parallel run finished. (Total time: %s)',
                        pretty_tdelta(ar.wall_time))
            cs.close()

